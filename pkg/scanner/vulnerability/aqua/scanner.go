package aqua

import (
	"context"
	"fmt"

	"github.com/aquasecurity/starboard-security-operator/pkg/scanner/vulnerability"

	"github.com/aquasecurity/starboard-security-operator/pkg/etc"
	"github.com/aquasecurity/starboard/pkg/apis/aquasecurity/v1alpha1"
	"github.com/aquasecurity/starboard/pkg/kube"
	"github.com/aquasecurity/starboard/pkg/kube/pod"
	"github.com/google/uuid"
	batch "k8s.io/api/batch/v1"
	core "k8s.io/api/core/v1"
	meta "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/klog"
	"k8s.io/utils/pointer"
)

type aquaScanner struct {
	config    etc.Config
	pods      *pod.Manager
	converter Converter
}

func NewScanner(config etc.Config, pods *pod.Manager, converter Converter) vulnerability.Scanner {
	return &aquaScanner{
		config:    config,
		pods:      pods,
		converter: converter,
	}
}

func (s *aquaScanner) PrepareScanJob(_ context.Context, pod *core.Pod) *batch.Job {
	resource := GetImmediateOwnerReference(pod)

	scanJobContainers := make([]core.Container, len(pod.Spec.Containers))
	for i, container := range pod.Spec.Containers {
		scanJobContainers[i] = s.newScanJobContainer(container)
	}

	return &batch.Job{
		ObjectMeta: meta.ObjectMeta{
			Name:      uuid.New().String(),
			Namespace: s.config.Operator.StarboardNamespace,
			Labels: labels.Set{
				kube.LabelResourceKind:      string(resource.Kind),
				kube.LabelResourceName:      resource.Name,
				kube.LabelResourceNamespace: resource.Namespace,
			},
		},
		Spec: batch.JobSpec{
			BackoffLimit: pointer.Int32Ptr(0),
			Template: core.PodTemplateSpec{
				Spec: core.PodSpec{
					RestartPolicy: core.RestartPolicyNever,
					Volumes: []core.Volume{
						{
							Name: "dockersock",
							VolumeSource: core.VolumeSource{
								HostPath: &core.HostPathVolumeSource{
									Path: "/var/run/docker.sock",
								},
							},
						},
					},
					Containers: scanJobContainers,
				},
			},
		},
	}
}

func (s *aquaScanner) newScanJobContainer(podContainer core.Container) core.Container {
	return core.Container{
		Name: podContainer.Name,
		Image: fmt.Sprintf("%s/scanner:%s",
			s.config.ScannerAquaCSP.RegistryServer,
			s.config.ScannerAquaCSP.Version),
		ImagePullPolicy: core.PullNever,
		Command: []string{
			"/bin/sh",
			"-c",
			fmt.Sprintf("/opt/aquasec/scannercli scan --checkonly --host $(OPERATOR_SCANNER_AQUA_CSP_HOST) --user $(OPERATOR_SCANNER_AQUA_CSP_USER) --password $(OPERATOR_SCANNER_AQUA_CSP_PASSWORD) --local %s 2> %s",
				podContainer.Image,
				core.TerminationMessagePathDefault),
		},
		Env: []core.EnvVar{
			{
				Name: "OPERATOR_SCANNER_AQUA_CSP_HOST",
				ValueFrom: &core.EnvVarSource{
					SecretKeyRef: &core.SecretKeySelector{
						LocalObjectReference: core.LocalObjectReference{
							Name: "starboard-security-operator",
						},
						Key: "OPERATOR_SCANNER_AQUA_CSP_HOST",
					},
				},
			},
			{
				Name: "OPERATOR_SCANNER_AQUA_CSP_USER",
				ValueFrom: &core.EnvVarSource{
					SecretKeyRef: &core.SecretKeySelector{
						LocalObjectReference: core.LocalObjectReference{
							Name: "starboard-security-operator",
						},
						Key: "OPERATOR_SCANNER_AQUA_CSP_USER",
					},
				},
			},
			{
				Name: "OPERATOR_SCANNER_AQUA_CSP_PASSWORD",
				ValueFrom: &core.EnvVarSource{
					SecretKeyRef: &core.SecretKeySelector{
						LocalObjectReference: core.LocalObjectReference{
							Name: "starboard-security-operator",
						},
						Key: "OPERATOR_SCANNER_AQUA_CSP_PASSWORD",
					},
				},
			},
		},
		VolumeMounts: []core.VolumeMount{
			{
				Name:      "dockersock",
				MountPath: "/var/run/docker.sock",
			},
		},
	}
}

func (s *aquaScanner) GetVulnerabilityReportsByScanJob(ctx context.Context, scanJob *batch.Job) (map[string]v1alpha1.VulnerabilityReport, error) {
	vulnerabilityReports := make(map[string]v1alpha1.VulnerabilityReport)

	for _, container := range scanJob.Spec.Template.Spec.Containers {
		vulnerabilityReport, err := s.processVulnerabilityReportByContainer(ctx, scanJob, container.Name)
		if err != nil {
			klog.Errorf("Error while processing complete scan job by container: %v", err)
			continue
		}
		vulnerabilityReports[container.Name] = vulnerabilityReport
	}
	return vulnerabilityReports, nil
}

func (s *aquaScanner) processVulnerabilityReportByContainer(ctx context.Context, scanJob *batch.Job, container string) (v1alpha1.VulnerabilityReport, error) {
	logsReader, err := s.pods.GetContainerLogsByJob(ctx, scanJob, container)
	if err != nil {
		return v1alpha1.VulnerabilityReport{}, fmt.Errorf("getting logs from container %s of %s/%s: %w", container, scanJob.Namespace, scanJob.Name, err)
	}
	defer func() {
		_ = logsReader.Close()
	}()
	vulnerabilityReport, err := s.converter.Convert(logsReader)
	if err != nil {
		return v1alpha1.VulnerabilityReport{}, fmt.Errorf("converting logs to scan report: %w", err)
	}

	return vulnerabilityReport, nil
}

// TODO Climb up the owners hierarchy and use the root?
// TODO Move such utility function to libstarboard
// TODO Add GetRootOwnerReference to have another option
func GetImmediateOwnerReference(pod *core.Pod) kube.Object {
	ownerRef := meta.GetControllerOf(pod)
	if ownerRef != nil {
		return kube.Object{
			Namespace: pod.Namespace,
			Kind:      kube.Kind(ownerRef.Kind),
			Name:      ownerRef.Name,
		}
	}
	return kube.Object{
		Namespace: pod.Namespace,
		Kind:      kube.KindPod,
		Name:      pod.Name,
	}
}
